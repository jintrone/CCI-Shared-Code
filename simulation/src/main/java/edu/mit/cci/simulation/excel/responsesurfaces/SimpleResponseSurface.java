package edu.mit.cci.simulation.excel.responsesurfaces;


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;


/**
 * A response surface describes the output of a model by interpolating unknown points on the output surface
 * from known points given a set of outputs generated by adjacent input parameter settings.
 * <p/>
 * The SimpleResponseSurface assumes a two dimensional output surface, with known points provided as a set
 * of adjacent one-dimensional datasets.
 * <p/>
 * Within this model, the interpolated surface between two adjacent datasets is referred to as a {@see Slice}.
 * The full response surface is a set of adjacent slices.
 * <p/>
 * This class is generic, and is parameterized by the datatype relevant to the response surface as follows:
 * <li>
 * <ul>T - the datatype for the values in the input space that bounds a particular dataset (e.g. Emissions between x and y)</ul>
 * <ul>U - the datatype for the indices at which functions are defined within each dataset (e.g. Year) </ul>
 * <li>
 */

public class SimpleResponseSurface<T extends Comparable<T>, U extends Comparable<U>> {


    private U[] defaultindices = null;

    private List<Slice<T, U>> slices = new ArrayList<Slice<T, U>>();

    /**
     * Adds a slice to this response surface.  Slices are maintained in order (according to {@link Slice#compareTo(Slice)}).
     * Newly added slices must have the same number of indices as existing slices
     *
     * @param from      The lower bounds of the input space to which this slice applies
     * @param to        The upper bounds of the input space to which this slice applies
     * @param indices   The indices for which different functions are defined
     * @param equations The function that interpolates between outputs between lower / upper bounds in the input space
     */
    public Slice<T,U> addSlice(T[] from, T[] to, U[] indices, Polynomial[] equations) {
        if (defaultindices != null) {
            if (!Arrays.equals(defaultindices, indices)) {
                throw new IllegalArgumentException("Added slices must have the same indices as other slices");
            } else {
                if (from.length != to.length || from.length != indices.length || from.length != equations.length) {
                    throw new IllegalArgumentException("All inputs must be of equal length");
                }
                defaultindices = indices;
            }
        }

        Slice<T, U> s = new Slice<T, U>();
        for (int i = 0; i < indices.length - 1; i++) {
            s.add(new SliceSegment<T, U>(from[i], to[i + i], indices[i], equations[i]));
        }
        slices.add(s);
        Collections.sort(slices);
        return s;
    }

    /**
     * Adds a slice to this response surface.  Slices are maintained in order (according to {@link Slice#compareTo(Slice)}).
     * Newly added slices must have the same number of indices as existing slices
     *
     * @param s  The slice to add
     * @return
     */
    public Slice<T,U> addSlice(Slice<T,U> s) {
        List<U> idxs = new ArrayList<U>();
        for (SliceSegment<T,U> seg:s) {
          idxs.add(seg.getIndex());
        }

        //argh, java
        U[] ary = idxs.toArray((U[]) new Comparable[0]);
        if (defaultindices !=null) {
            if (!Arrays.equals(ary,defaultindices)) {
              throw new IllegalArgumentException("Added slices must have the same indices as other slices");
            }
        } else {
            defaultindices = ary;
        }

        slices.add(s);
        Collections.sort(slices);
        return s;

    }

    /**
     * Provides an unmodifiable view of the underlying slices
     *
     * @return
     */
    public List<Slice<T, U>> getSlices() {
        return Collections.unmodifiableList(slices);
    }


    /**
     * Returns a list of {@link SliceSegment}s at the specified index value,
     * or null if the index does not exist
     *
     * @param index
     * @return
     */
    public List<SliceSegment<T,U>> getAtIndex(U index) {
        int pos = -1;

        for (int i=0;i<defaultindices.length;i++) {
            if (defaultindices[i].equals(index)) {
                pos = i;
                break;
            }
        }
        if (pos<0) {
            return null;
        } else {
           List<SliceSegment<T,U>> result = new ArrayList<SliceSegment<T, U>>();
           for (Slice<T,U> s:slices) {
              result.add(s.get(pos));
            }
            return result;
        }


    }

    /**
     * Removes the slice. If this is the last slice to be removed, the
     * indices for the response surface are reset
     *
     * @param slice
     * @return true if a slice was removed
     */
    public boolean removeSlice(Slice<T, U> slice) {
        boolean result = slices.remove(slice);
        if (slices.isEmpty()) {
            defaultindices = null;
        }
        return result;

    }



}
